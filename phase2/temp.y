%{ #include <stdio.h> #include <stdlib.h> void yyerror(const char *msg) extern int currLine extern int currPos FILE * yyin int yylex()%}%union{  int ival  char* sval}%error-verbose%start program%token FUNCTION BEGIN_PARAMS END_PARAMS BEGIN_LOCALS END_LOCALS BEGIN_BODY END_BODY INTEGER SEMICOLON COMMA COLON L_SQUARE_BRACKET R_SQUARE_BRACKET ARRAY OF  %token ASSIGN IF THEN ELSE ENDIF WHILE BEGINLOOP ENDLOOP READ WRITE CONTINUE RETURN DO FOR %token OR AND NOT TRUE FALSE L_PAREN R_PAREN EQ NEQ LT GT LTE GTE%token ADD SUB MULT DIV MOD %token <sval> IDENT %token <ival> NUMBER%% program ::=				| function program          			   function ::=   FUNCTION identifier SEMICOLON BEGIN_PARAMS decline END_PARAMS BEGIN_LOCALS decline END_LOCALS BEGIN_BODY statline END_BODY                          declaration ::=    identifier COMMA declaration | identifier COLON INTEGER | identifier COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER                         number ::=     NUMBER                         decline ::=    | declaration SEMICOLON decline                      identifier ::=    IDENT                               statement ::=  var ASSIGN expression | IF boolexp THEN statline stathelp ENDIF| WHILE boolexp BEGINLOOP statline ENDLOOP | DO BEGINLOOP statline ENDLOOP WHILE boolexp | FOR var ASSIGN number SEMICOLON boolexp SEMICOLON var ASSIGN expression BEGINLOOP statline ENDLOOP | READ varline| WRITE varline| CONTINUE | RETURN expression                                  stathelp ::=   | ELSE statline                      varline ::=    var | var COMMA varline                      statline ::=   | statement SEMICOLON statline                      boolexp ::=    relationandexpr| relationandexpr OR boolexp                      relationandexpr ::=    relationexpr | relationexpr AND relationandexpr                              relationexpr ::=   NOT relationhelper | relationhelper                          relationhelper ::=    expression comp expression | TRUE | FALSE | L_PAREN boolexp R_PAREN comp ::=       EQ | NEQ | LT | GT | LTE | GTE                      expression ::=     multiplicativeexp | multiplicativeexp ADD expression | multiplicativeexp SUB expressionmultiplicativeexp ::=  term | term MULT multiplicativeexp | term DIV multiplicativeexp | term MOD multiplicativeexp                              term ::=       term1                      | SUB term1                      | identifier L_PAREN expresscomm R_PAREN                      term1 ::=      var                      | number                      | L_PAREN expression R_PAREN                      var ::=        identifier                      | identifier L_SQUARE_BRACKET expression R_SQUARE_BRACKET                      expresscomm ::=    expression                                  | expression COMMA expresscomm                          %%int main(int argc, char **argv) {   if (argc > 1) {      yyin = fopen(argv[1], "r\n")      if (yyin == NULL){         printf("syntax ::= %s filename\n", argv[0])      }//end if   }//end if   yyparse() // Calls yylex() for tokens.   return 0}void yyerror(const char *msg) {   printf("** Line %d, position %d ::= %s\n", currLine, currPos, msg)}